{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Django REST Framework Toolkit","text":"<p>A comprehensive toolkit that extends Django REST Framework with enhanced functionality and common patterns.</p>"},{"location":"index.html#overview","title":"Overview","text":"<p>Django and DRF provide an awesome combination for building REST APIs.</p> <p>DRF supports many great plugins that extend its capabilities even further.</p> <p>The DRF Toolkit applies common RESTFul patterns to the framework by adding base classes that can be used in your existing DRF projects.</p> <p>Most use cases are covered by DRF Toolkit, allowing your project to be simpler so you can focus on the business logic.</p>"},{"location":"index.html#motivation","title":"Motivation","text":"<p>While Django REST Framework provides excellent foundations for building APIs, developers often find themselves reimplementing common patterns or searching for multiple packages to fill functionality gaps. DRF Toolkit addresses these challenges by:</p> <ul> <li> <p>Comprehensive Feature Set: Providing a unified solution for common API requirements like soft deletion, diff tracking, advanced filtering, and nested resources, eliminating the need for multiple third-party packages.</p> </li> <li> <p>Enhanced Extensibility: Offering base classes and mixins that seamlessly integrate with DRF, making it easy to extend and customize functionality while maintaining clean, maintainable code.</p> </li> <li> <p>Production-Ready Features: Including optimized solutions for caching, pagination, and database operations that are battle-tested and performance-focused.</p> </li> <li> <p>Developer Experience: Reducing boilerplate code and providing intuitive abstractions that make it easier to implement complex API patterns while following REST best practices.</p> </li> <li> <p>Missing DRF Features: Filling gaps in DRF's core functionality with features like automatic field handling, enhanced model tracking, and comprehensive testing utilities.</p> </li> </ul>"},{"location":"index.html#features","title":"Features","text":"<p>DRF Toolkit provides a comprehensive set of tools and utilities for Django REST Framework:</p> <ul> <li>Models: Enhanced model functionality with diff tracking, soft delete, and more</li> <li>Serializers: Advanced serialization with automatic field handling</li> <li>Views: Extended viewsets with caching, filtering, and nested resources</li> <li>Filters: Powerful filtering capabilities with multiple filter types</li> <li>Pagination: Optimized pagination for better performance</li> <li>Caching: Flexible caching system with custom key generation</li> <li>Signals: Model operation tracking and signal management</li> <li>Testing: Comprehensive testing utilities for API endpoints</li> </ul> <p>Additional features include: - Fields: Custom model and serializer fields - Storage: Enhanced file storage capabilities</p> <p>Check out our detailed documentation sections to learn more about each feature.</p>"},{"location":"caching.html","title":"Caching","text":"<p>DRF Toolkit provides a flexible caching system with robust cache key generation and support for cache directives.</p>"},{"location":"caching.html#enabling-cache","title":"Enabling Cache","text":"<p>Enable caching in your viewsets by using the pre-built cached viewsets from drf_kit:</p> <pre><code>from drf_kit.viewsets import CachedModelViewSet\n\nclass UserViewSet(CachedModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    cache_timeout = 300  # Cache for 5 minutes\n</code></pre>"},{"location":"caching.html#cache-key-generation","title":"Cache Key Generation","text":"<p>The toolkit uses a robust <code>CacheKeyConstructor</code> that generates unique cache keys based on: - Unique view method identifier - URL arguments - URL keyword arguments - Query parameters (including handling of multiple values) - Request's accepted media type</p>"},{"location":"caching.html#configuration","title":"Configuration","text":"<p>You can configure the cache key generation function globally in your settings:</p> <pre><code>REST_FRAMEWORK_EXTENSIONS = {\n    'DEFAULT_CACHE_KEY_FUNC':\n        'drf_kit.cache.cache_key_constructor'\n}\n</code></pre>"},{"location":"caching.html#cache-directives","title":"Cache Directives","text":"<p>The caching system respects HTTP cache control directives. Currently supported:</p> <ul> <li><code>no-cache</code>: Forces a fresh response, bypassing the cache</li> <li>When cache is used, responses include:</li> <li><code>Expires</code> header with the expiration timestamp</li> <li><code>Cache-Control: max-age=&lt;timeout&gt;</code> header</li> <li><code>X-Cache: HIT/MISS</code> header indicating cache status</li> </ul>"},{"location":"caching.html#advanced-usage","title":"Advanced Usage","text":""},{"location":"caching.html#custom-cache-timeout","title":"Custom Cache Timeout","text":"<p>You can customize the cache timeout per viewset:</p> <pre><code>class UserViewSet(CachedModelViewSet):\n    cache_timeout = 3600  # Cache for 1 hour\n</code></pre>"},{"location":"caching.html#custom-cache-key-constructor","title":"Custom Cache Key Constructor","text":"<p>While the default <code>CacheKeyConstructor</code> is suitable for most cases, you can create your own key constructor by extending it:</p> <pre><code>from drf_kit.cache import CacheKeyConstructor\nfrom rest_framework_extensions.key_constructor import bits\n\nclass CustomCacheKeyConstructor(CacheKeyConstructor):\n    # Add custom bits for key generation\n    user_id = bits.UserKeyBit()\n\ncustom_cache_key_constructor = CustomCacheKeyConstructor()\n\nclass UserViewSet(CachedModelViewSet):\n    cache_key_constructor = custom_cache_key_constructor\n</code></pre>"},{"location":"caching.html#best-practices","title":"Best Practices","text":"<ol> <li>Choose appropriate cache timeouts:</li> <li>Short for frequently changing data</li> <li>Longer for stable data</li> <li>Consider user-specific needs</li> </ol>"},{"location":"contributing.html","title":"Contributing to DRF Toolkit","text":"<p>We love your input! We want to make contributing to DRF Toolkit as easy and transparent as possible, whether it's:</p> <ul> <li>Reporting a bug</li> <li>Discussing the current state of the code</li> <li>Submitting a fix</li> <li>Proposing new features</li> <li>Becoming a maintainer</li> </ul>"},{"location":"contributing.html#development-process","title":"Development Process","text":"<p>We use GitHub to host code, to track issues and feature requests, as well as accept pull requests.</p> <ol> <li>Fork the repo and create your branch from <code>main</code></li> <li>If you've added code that should be tested, add tests</li> <li>If you've changed APIs, update the documentation</li> <li>Ensure the test suite passes</li> <li>Make sure your code lints</li> <li>Issue that pull request!</li> </ol>"},{"location":"contributing.html#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Update the README.md with details of changes to the interface, if applicable</li> <li>Update the documentation with any new features or changes</li> <li>The PR may be merged once you have the sign-off of at least one other developer</li> <li>Follow the Development Setup Guide for local development instructions</li> </ol>"},{"location":"contributing.html#any-contributions-you-make-will-be-under-the-mit-software-license","title":"Any Contributions You Make Will Be Under the MIT Software License","text":"<p>In short, when you submit code changes, your submissions are understood to be under the same MIT License that covers the project. Feel free to contact the maintainers if that's a concern.</p>"},{"location":"contributing.html#report-bugs-using-githubs-issue-tracker","title":"Report Bugs Using GitHub's Issue Tracker","text":"<p>We use GitHub issues to track public bugs. Report a bug by opening a new issue.</p>"},{"location":"contributing.html#write-bug-reports-with-detail-background-and-sample-code","title":"Write Bug Reports With Detail, Background, and Sample Code","text":"<p>Great Bug Reports tend to have:</p> <ul> <li>A quick summary and/or background</li> <li>Steps to reproduce</li> <li>Be specific!</li> <li>Give sample code if you can</li> <li>What you expected would happen</li> <li>What actually happens</li> <li>Notes (possibly including why you think this might be happening, or stuff you tried that didn't work)</li> </ul>"},{"location":"contributing.html#use-a-consistent-coding-style","title":"Use a Consistent Coding Style","text":"<ul> <li>Use ruff for code formatting and linting</li> <li>Follow PEP 8 style guide</li> <li>Write docstrings for all public methods and classes</li> <li>Run <code>make style</code> before submitting your changes</li> </ul>"},{"location":"contributing.html#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under its MIT License.</p>"},{"location":"contributing.html#references","title":"References","text":"<p>This document was adapted from the open-source contribution guidelines for Facebook's Draft.</p>"},{"location":"development.html","title":"Development Setup","text":"<p>This guide will help you set up your development environment for contributing to DRF Toolkit.</p>"},{"location":"development.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9 or higher</li> <li>pip (Python package installer)</li> <li>Git</li> </ul>"},{"location":"development.html#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/flamingo-run/drf-toolkit.git\ncd drf-toolkit\n</code></pre></p> </li> <li> <p>Create a virtual environment:    <pre><code>python -m venv .venv\nsource .venv/bin/activate  # On Windows use: .venv\\Scripts\\activate\n</code></pre></p> </li> <li> <p>Install development dependencies:    <pre><code>make dependencies\n</code></pre></p> </li> </ol>"},{"location":"development.html#running-tests","title":"Running Tests","text":"<p>To run the test suite:</p> <pre><code>make test      # Run all checks including linting and unit tests\nmake unit      # Run only unit tests\n</code></pre>"},{"location":"development.html#code-style","title":"Code Style","text":"<p>We use ruff for code formatting and linting.</p> <p>To check your code: <pre><code>make lint      # Check code style\n</code></pre></p> <p>To automatically format your code: <pre><code>make style     # Apply code style fixes\n</code></pre></p>"},{"location":"development.html#documentation","title":"Documentation","text":"<p>To build and serve the documentation locally:</p> <pre><code>mkdocs serve\n</code></pre> <p>Then visit http://127.0.0.1:8000 in your web browser.</p>"},{"location":"development.html#making-changes","title":"Making Changes","text":"<ol> <li> <p>Create a new branch for your changes:    <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Make your changes and ensure all tests pass</p> </li> <li>Update documentation if necessary</li> <li>Submit a pull request</li> </ol> <p>For more detailed information about contributing, please see our Contributing Guide.</p>"},{"location":"fields.html","title":"Custom Fields","text":"<p>DRF Toolkit provides custom fields that extend Django's built-in fields with additional functionality.</p>"},{"location":"fields.html#defaulttimezonedatetimefield","title":"DefaultTimezoneDateTimeField","text":"<p>A custom DateTime field that ensures consistent timezone handling by always using the project's default timezone (<code>settings.TIME_ZONE</code>), regardless of the current request's timezone context.</p> <p>This is particularly useful when you want to ensure that datetime fields are always handled in the project's default timezone, preventing issues with middleware or context-specific timezone changes.</p>"},{"location":"fields.html#usage","title":"Usage","text":"<pre><code>from drf_kit.fields import DefaultTimezoneDateTimeField\nfrom rest_framework import serializers\n\nclass EventSerializer(serializers.ModelSerializer):\n    created_at = DefaultTimezoneDateTimeField()\n    scheduled_at = DefaultTimezoneDateTimeField(required=False)\n\n    class Meta:\n        model = Event\n        fields = ['id', 'created_at', 'scheduled_at']\n</code></pre>"},{"location":"fields.html#key-features","title":"Key Features","text":"<ul> <li>Always uses the project's default timezone from settings</li> <li>Prevents timezone inconsistencies from middleware or context changes</li> <li>Compatible with Django REST Framework's datetime handling</li> </ul>"},{"location":"fields.html#slugifyfield","title":"SlugifyField","text":"<p>An enhanced version of Django's SlugField that automatically applies slugification to the field value before saving. It allows customization of the slugify function used.</p>"},{"location":"fields.html#usage_1","title":"Usage","text":"<pre><code>from drf_kit.fields import SlugifyField\nfrom django.db import models\n\nclass Article(models.Model):\n    title = models.CharField(max_length=100)\n    slug = SlugifyField(max_length=100)  # Will automatically slugify from title\n</code></pre>"},{"location":"fields.html#custom-slugify-function","title":"Custom Slugify Function","text":"<p>You can provide a custom slugify function:</p> <pre><code>def custom_slugify(value):\n    # Your custom slugification logic\n    return value.lower().replace(' ', '-')\n\nclass Article(models.Model):\n    title = models.CharField(max_length=100)\n    slug = SlugifyField(max_length=100, func=custom_slugify)\n</code></pre>"},{"location":"fields.html#parameters","title":"Parameters","text":"<ul> <li><code>max_length</code> (int): Maximum length for the slug (default: 50)</li> <li><code>db_index</code> (bool): Whether to create a database index (default: True)</li> <li><code>allow_unicode</code> (bool): Whether to allow unicode characters in slugs (default: False)</li> <li><code>func</code> (callable): Custom slugify function (default: django.utils.text.slugify)</li> </ul>"},{"location":"fields.html#example-with-all-options","title":"Example with All Options","text":"<pre><code>class Article(models.Model):\n    title = models.CharField(max_length=100)\n    slug = SlugifyField(\n        max_length=100,\n        db_index=True,\n        allow_unicode=True,\n        func=custom_slugify\n    )\n</code></pre>"},{"location":"fields.html#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>DefaultTimezoneDateTimeField</code> when you need consistent timezone handling across your application</li> <li>Use <code>SlugifyField</code> for automatic URL-friendly slug generation</li> <li>Consider providing custom slugify functions when you need special slug formatting</li> <li>Remember to handle edge cases in custom slugify functions</li> </ol>"},{"location":"filters.html","title":"Filters","text":"<p>DRF Toolkit provides powerful filtering capabilities with custom filter types and filter backends designed to handle common filtering scenarios efficiently.</p>"},{"location":"filters.html#filterbackend","title":"FilterBackend","text":"<p>A custom filter backend that provides better error handling by converting <code>ValueError</code> and <code>AttributeError</code> exceptions into HTTP 400 responses with clear error messages.</p> <p>You can configure the FilterBackend at the settings level for all viewsets:</p> <pre><code># settings.py\nREST_FRAMEWORK = {\n    'DEFAULT_FILTER_BACKENDS': ['drf_kit.filters.FilterBackend']\n}\n</code></pre> <p>Or configure it at the viewset level for specific views:</p> <pre><code>from drf_kit.filters import FilterBackend\n\nclass UserViewSet(ModelViewSet):\n    filter_backends = [FilterBackend]\n    filterset_class = UserFilterSet\n</code></pre>"},{"location":"filters.html#filter-types","title":"Filter Types","text":""},{"location":"filters.html#intbooleanfilter","title":"IntBooleanFilter","text":"<p>A filter that converts integer values (0/1) to boolean filters. Useful for boolean fields in querystrings.</p> <pre><code>from drf_kit.filters import IntBooleanFilter, FilterSet\n\nclass UserFilterSet(FilterSet):\n    is_active = IntBooleanFilter()\n\n# Usage:\n# GET /api/users/?is_active=1  # Returns active users\n# GET /api/users/?is_active=0  # Returns inactive users\n</code></pre>"},{"location":"filters.html#anyoffilter","title":"AnyOfFilter","text":"<p>Performs an OR operation when multiple values are provided for the same field. Values are provided by repeating the query parameter.</p> <pre><code>from drf_kit.filters import AnyOfFilter, FilterSet\n\nclass UserFilterSet(FilterSet):\n    status = AnyOfFilter()\n\n# Usage:\n# GET /api/users/?status=active&amp;status=pending  # Returns users with status active OR pending\n</code></pre>"},{"location":"filters.html#alloffilter","title":"AllOfFilter","text":"<p>Similar to AnyOfFilter but performs an AND operation. Must be used with <code>conjoined=True</code>.</p> <pre><code>from drf_kit.filters import AllOfFilter, FilterSet\n\nclass UserFilterSet(FilterSet):\n    roles = AllOfFilter()  # conjoined=True by default\n\n# Usage:\n# GET /api/users/?roles=admin&amp;roles=moderator  # Returns users that have BOTH roles\n</code></pre>"},{"location":"filters.html#anyofornullfilter","title":"AnyOfOrNullFilter","text":"<p>Extends AnyOfFilter to handle null values. Use \"null\" as a special keyword to filter for null values.</p> <pre><code>from drf_kit.filters import AnyOfOrNullFilter, FilterSet\n\nclass UserFilterSet(FilterSet):\n    supervisor = AnyOfOrNullFilter()\n\n# Usage:\n# GET /api/users/?supervisor=null  # Returns users with no supervisor\n# GET /api/users/?supervisor=123&amp;supervisor=null  # Returns users with supervisor_id=123 OR no supervisor\n</code></pre>"},{"location":"filters.html#basefilterset","title":"BaseFilterSet","text":"<p>A FilterSet that allows setting default/initial values for filters. The initial value can be a static value or a callable.</p> <pre><code>from drf_kit.filters import BaseFilterSet, IntBooleanFilter\n\nclass UserFilterSet(BaseFilterSet):\n    is_active = IntBooleanFilter(initial=1)  # Static initial value\n    department = CharFilter(initial=lambda request: request.user.department)  # Callable initial value\n\n    class Meta:\n        model = User\n        fields = ['is_active', 'department']\n\n# Usage:\n# GET /api/users/  # By default, returns only active users\n# GET /api/users/?is_active=0  # Overrides default and returns inactive users\n</code></pre>"},{"location":"filters.html#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>FilterBackend</code> to get better error handling with 400 responses for invalid filter values</li> <li>Choose appropriate filter types based on your filtering needs:</li> <li><code>IntBooleanFilter</code> for boolean fields</li> <li><code>AnyOfFilter</code> for OR operations</li> <li><code>AllOfFilter</code> for AND operations</li> <li><code>AnyOfOrNullFilter</code> when null values need special handling</li> <li>Use <code>BaseFilterSet</code> when you need default filter values</li> </ol>"},{"location":"installation.html","title":"Installation","text":"<p>Installing DRF Toolkit is straightforward using pip:</p> <pre><code>pip install drf-toolkit\n</code></pre>"},{"location":"installation.html#quick-start","title":"Quick Start","text":"<p>After installing the package, you can start using the toolkit's features by importing the necessary components in your Django project.</p> <p>For example, to use the enhanced model functionality:</p> <pre><code>from drf_toolkit.models import DiffModel\n\nclass YourModel(DiffModel):\n    # Your model fields here\n    pass\n</code></pre> <p>Check out the specific feature documentation pages to learn more about how to use each component of DRF Toolkit.</p>"},{"location":"models.html","title":"Models","text":"<p>DRF Toolkit provides a rich set of model types and mixins to enhance Django's model functionality. Each model type is designed to handle specific use cases while maintaining clean and organized code.</p>"},{"location":"models.html#available-models","title":"Available Models","text":""},{"location":"models.html#base-models","title":"Base Models","text":"<ul> <li>Base Models - Core functionality including timestamps and change tracking</li> <li>Diff Models - Track changes to model fields</li> </ul>"},{"location":"models.html#feature-models","title":"Feature Models","text":"<ul> <li>Availability Models - Time-based availability management</li> <li>File Models - Enhanced file handling capabilities</li> <li>Inheritance Models - Advanced model inheritance support</li> <li>Ordered Models - Automatic sequence management</li> <li>Soft Delete Models - Soft deletion functionality</li> </ul>"},{"location":"models.html#combined-models","title":"Combined Models","text":"<p>See Model Combinations for pre-built combinations and custom combination guidelines.</p>"},{"location":"models.html#quick-start","title":"Quick Start","text":"<p>Most models should inherit from BaseModel or one of its variants:</p> <pre><code>from drf_kit.models import BaseModel\n\nclass SimpleModel(BaseModel):\n    name = models.CharField(max_length=100)\n    # Automatically includes:\n    # - created_at\n    # - updated_at\n    # - change tracking\n    # - file handling\n</code></pre> <p>For more complex needs, use feature-specific models:</p> <pre><code>from drf_kit.models import (\n    SoftDeleteModel,\n    AvailabilityModel,\n    OrderedModel\n)\n\n# Soft deletion support\nclass Document(SoftDeleteModel):\n    title = models.CharField(max_length=100)\n\n# Time-based availability\nclass Event(AvailabilityModel):\n    name = models.CharField(max_length=100)\n\n# Automatic ordering\nclass PlaylistItem(OrderedModel):\n    song = models.CharField(max_length=100)\n</code></pre>"},{"location":"models.html#best-practices","title":"Best Practices","text":"<ol> <li>Always inherit from BaseModel or its variants instead of models.Model</li> <li>Choose the most specific model type for your needs</li> <li>Use model combinations when you need multiple features</li> <li>Follow the documentation for each model type</li> <li>Consider performance implications when combining features</li> </ol> <p>For detailed documentation on each model type, click the respective links above.</p>"},{"location":"pagination.html","title":"Pagination","text":"<p>DRF Toolkit provides enhanced pagination capabilities that extend Django REST Framework's built-in pagination classes. Our implementation focuses on flexibility and performance optimization.</p>"},{"location":"pagination.html#available-pagination-classes","title":"Available Pagination Classes","text":""},{"location":"pagination.html#custompagepagination","title":"CustomPagePagination","text":"<p>The <code>CustomPagePagination</code> class extends DRF's <code>PageNumberPagination</code> with additional customization options:</p> <pre><code>from drf_kit.pagination import CustomPagePagination\n\nclass MyPagination(CustomPagePagination):\n    page_size = 100\n    page_size_query_param = 'page_size'  # Allow client to override page size\n    page_start = 1  # Default is 1, but can be customized\n</code></pre> <p>Key features: - Customizable starting page number (default: 1) - Dynamic page size through query parameters - Smart URL handling:   - First page: removes page parameter entirely (e.g., /api/users/)   - Other pages: includes page number (e.g., /api/users/?page=2) - Full compatibility with DRF's browsable API including pagination controls - Proper handling of edge cases (invalid pages, empty results)</p> <p>Usage example: <pre><code># In your viewset\nfrom rest_framework.viewsets import ModelViewSet\n\nclass UserViewSet(ModelViewSet):\n    queryset = User.objects.all()\n    pagination_class = MyPagination\n</code></pre></p> <p>API requests: <pre><code>GET /api/users/           # First page (when page_start = 1)\nGET /api/users/?page=2    # Second page\nGET /api/users/?page_size=50  # Custom page size\n</code></pre></p> <p>Response format: <pre><code>{\n    \"count\": 100,\n    \"next\": \"http://api.example.org/users/?page=2\",\n    \"previous\": \"http://api.example.org/users/?page=1\",\n    \"results\": []\n}\n</code></pre></p>"},{"location":"pagination.html#lightpagepagination","title":"LightPagePagination","text":"<p>The <code>LightPagePagination</code> is a lighter version of <code>CustomPagePagination</code> that omits the total count query, making it more efficient for large datasets:</p> <pre><code>from drf_kit.pagination import LightPagePagination\n\nclass FastPagination(LightPagePagination):\n    page_size = 100\n    page_size_query_param = 'page_size'\n    page_start = 1\n</code></pre> <p>Key features: - Inherits all customization options from CustomPagePagination - Removes the expensive COUNT query for better performance - Smart next page detection:   - Has next page if current page size equals requested page size   - No additional query needed for this check - Maintains proper URL handling and browsable API support - Ideal for large datasets where total count isn't necessary or too expensive</p> <p>Response format: <pre><code>{\n    \"next\": \"http://api.example.org/users/?page=2\",\n    \"previous\": \"http://api.example.org/users/?page=1\",\n    \"results\": []\n}\n</code></pre></p>"},{"location":"pagination.html#configuration","title":"Configuration","text":""},{"location":"pagination.html#global-configuration","title":"Global Configuration","text":"<p>To set a default pagination class for all viewsets, add to your Django settings:</p> <pre><code>REST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'drf_kit.pagination.CustomPagePagination',\n    'PAGE_SIZE': 100\n}\n</code></pre>"},{"location":"pagination.html#per-view-configuration","title":"Per-View Configuration","text":"<p>Override pagination for specific viewsets:</p> <pre><code>from drf_kit.pagination import LightPagePagination\n\nclass UserViewSet(ModelViewSet):\n    pagination_class = LightPagePagination\n    page_size = 50\n</code></pre>"},{"location":"pagination.html#best-practices","title":"Best Practices","text":"<ol> <li>Choose the appropriate pagination class:</li> <li>Use <code>CustomPagePagination</code> when you need total count</li> <li> <p>Use <code>LightPagePagination</code> for large datasets or better performance</p> </li> <li> <p>Configure reasonable limits:</p> </li> <li>Set appropriate page sizes</li> <li>Consider your data volume and access patterns</li> <li>Use page_size_query_param wisely</li> </ol>"},{"location":"quick_start.html","title":"Quick Start Guide","text":"<p>This guide will help you get started with DRF Toolkit quickly. We'll cover installation, basic setup, and common use cases.</p>"},{"location":"quick_start.html#installation","title":"Installation","text":"<pre><code>pip install drf-toolkit\n</code></pre>"},{"location":"quick_start.html#basic-setup","title":"Basic Setup","text":"<ol> <li>Add <code>drf_kit</code> to your <code>INSTALLED_APPS</code>:</li> </ol> <pre><code>INSTALLED_APPS = [\n    ...\n    'drf_kit',\n]\n</code></pre> <ol> <li>Configure your Django REST Framework settings (if not already done):</li> </ol> <pre><code>REST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'drf_kit.pagination.PageNumberPagination',\n    'PAGE_SIZE': 100,\n}\n</code></pre>"},{"location":"quick_start.html#common-use-cases","title":"Common Use Cases","text":""},{"location":"quick_start.html#1-enhanced-models","title":"1. Enhanced Models","text":"<p>Use our enhanced model classes for common functionality:</p> <pre><code>from drf_kit.models import BaseModel\n\nclass User(BaseModel):\n    name = models.CharField(max_length=100)\n    email = models.EmailField(unique=True)\n</code></pre>"},{"location":"quick_start.html#2-advanced-filtering","title":"2. Advanced Filtering","text":"<p>Implement powerful filtering in your views:</p> <pre><code>from drf_kit.filters import FilterSet\n\nclass UserFilter(FilterSet):\n    class Meta:\n        model = User\n        fields = ['name', 'email']\n\nclass UserViewSet(viewsets.ModelViewSet):\n    queryset = User.objects.all()\n    filterset_class = UserFilter\n</code></pre>"},{"location":"quick_start.html#3-soft-delete","title":"3. Soft Delete","text":"<p>Add soft delete capability to your models:</p> <pre><code>from drf_kit.models import SoftDeleteModel\n\nclass Document(SoftDeleteModel):\n    title = models.CharField(max_length=100)\n    content = models.TextField()\n</code></pre>"},{"location":"quick_start.html#4-enhanced-serializers","title":"4. Enhanced Serializers","text":"<p>Use our enhanced serializers for better validation and flexibility:</p> <pre><code>from drf_kit.serializers import ModelSerializer\n\nclass UserSerializer(ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['id', 'name', 'email']\n</code></pre>"},{"location":"quick_start.html#next-steps","title":"Next Steps","text":"<ul> <li>Check out the Models documentation for more model features</li> <li>Learn about Serializers for advanced serialization</li> <li>Explore Views for enhanced viewset capabilities</li> <li>See Filters for advanced filtering options</li> <li>Review Testing for testing utilities</li> </ul> <p>For more detailed information about specific features, check the respective documentation sections.</p>"},{"location":"requirements.html","title":"Requirements","text":"<p>DRF Toolkit has the following core requirements:</p> <ul> <li>Python 3.11+</li> <li>Django 4.2+</li> <li>Django REST Framework 3.14+</li> </ul>"},{"location":"requirements.html#python-version-support","title":"Python Version Support","text":"<p>The toolkit officially supports:</p> <ul> <li>Python 3.11</li> <li>Python 3.12</li> <li>Python 3.13 (beta support)</li> </ul>"},{"location":"requirements.html#django-compatibility","title":"Django Compatibility","text":"<p>DRF Toolkit is tested and compatible with:</p> <ul> <li>Django 4.2 and above</li> <li>Django REST Framework 3.14 and above</li> </ul>"},{"location":"requirements.html#optional-dependencies","title":"Optional Dependencies","text":"<p>Depending on which features you use, you might need additional packages. Each feature's documentation page lists its specific dependencies, if any.</p>"},{"location":"requirements.html#development-requirements","title":"Development Requirements","text":"<p>If you're contributing to DRF Toolkit, you'll need additional packages for development and testing. See the Development Setup page for more details.</p>"},{"location":"serializers.html","title":"Serializers","text":"<p>DRF Toolkit extends Django REST Framework's serialization capabilities with enhanced functionality and automatic field handling.</p>"},{"location":"serializers.html#basemodelserializer","title":"BaseModelSerializer","text":"<p>The <code>BaseModelSerializer</code> is designed to work seamlessly with the BaseModel counterpart, providing enhanced functionality for model serialization.</p> <pre><code>from drf_kit.serializers import BaseModelSerializer\n\nclass UserSerializer(BaseModelSerializer):\n    class Meta:\n        model = User\n        fields = [*BaseModelSerializer.Meta.fields, \"name\", \"email\"]\n</code></pre>"},{"location":"serializers.html#key-features","title":"Key Features","text":"<ul> <li>Automatic timezone-aware DateTime field handling</li> <li>Built-in read-only fields for <code>id</code>, <code>created_at</code>, and <code>updated_at</code></li> <li>Disabled unique together validators (handled at database level)</li> <li>Customized field mapping for better default behavior</li> </ul>"},{"location":"serializers.html#foreignkeyfield","title":"ForeignKeyField","text":"<p>A custom field that extends <code>PrimaryKeyRelatedField</code> to add serializer-level validation for foreign key relationships. It supports both single and many-to-many relationships.</p> <pre><code>from drf_kit.serializers import ForeignKeyField\n\nclass UserSerializer(BaseModelSerializer):\n    department = ForeignKeyField(queryset=Department.objects.all())\n    groups = ForeignKeyField(queryset=Group.objects.all(), m2m=True)\n\n    class Meta:\n        model = User\n        fields = ['id', 'department', 'groups']\n</code></pre>"},{"location":"serializers.html#features","title":"Features","text":"<ul> <li>Write-only by default for better security</li> <li>Built-in support for many-to-many relationships</li> <li>Automatic primary key conversion</li> <li>Proper validation of foreign key constraints</li> </ul>"},{"location":"serializers.html#jsonencoder","title":"JSONEncoder","text":"<p>A powerful JSON encoder that extends Django's <code>DjangoJSONEncoder</code> to handle additional Python types commonly used in web applications.</p>"},{"location":"serializers.html#supported-types","title":"Supported Types","text":"<ul> <li>DateTime objects (with timezone handling)</li> <li>Decimal numbers</li> <li>TimeZone objects</li> <li>Django FileFields (converts to URLs)</li> <li>PostgreSQL Range objects</li> <li>Objects with <code>_json()</code> method</li> <li>Objects with <code>__dict__</code> attribute</li> </ul>"},{"location":"serializers.html#example-usage","title":"Example Usage","text":"<pre><code>data = {\n    'timestamp': datetime.now(),\n    'amount': Decimal('10.50'),\n    'timezone': ZoneInfo('UTC'),\n    'file': user.avatar,\n    'age_range': Range(lower=18, upper=25)\n}\n\nserialized = json.dumps(data, cls=JSONEncoder)\n</code></pre>"},{"location":"serializers.html#formatting-utilities","title":"Formatting Utilities","text":"<p>DRF Toolkit provides several utilities for consistent data formatting:</p>"},{"location":"serializers.html#as_str","title":"as_str","text":"<p>Converts values to string with special handling for datetime:</p> <pre><code>from drf_kit.serializers import as_str\n\n# Basic usage\nas_str(True)  # Returns \"True\"\nas_str(None)  # Returns None\n\n# DateTime handling\nfrom datetime import datetime, UTC\ndt = datetime(2023, 1, 1, 12, 0, 0, tzinfo=UTC)\nas_str(dt)  # Returns \"2023-01-01T12:00:00Z\"\n\n# Non-UTC timezone\nfrom zoneinfo import ZoneInfo\ndt = datetime(2023, 1, 1, 12, 0, 0, tzinfo=ZoneInfo(\"Asia/Hong_Kong\"))\nas_str(dt)  # Returns \"2023-01-01T04:00:00Z\" (converted to UTC)\n</code></pre>"},{"location":"serializers.html#assure_tz","title":"assure_tz","text":"<p>Ensures datetime objects have proper timezone:</p> <pre><code>from drf_kit.serializers import assure_tz\nfrom datetime import datetime\nfrom zoneinfo import ZoneInfo\n\n# From string\ndt_str = \"2023-01-01T12:00:00\"\ndt = assure_tz(dt_str)  # Returns datetime with default timezone\n\n# Custom timezone\ndt = datetime(2023, 1, 1, 12, 0, 0)  # naive datetime\ndt_hk = assure_tz(dt, tz=\"Asia/Hong_Kong\")  # Returns datetime with Hong Kong timezone\n\n# From existing datetime\ndt_utc = datetime(2023, 1, 1, 12, 0, 0, tzinfo=UTC)\ndt = assure_tz(dt_utc)  # Returns datetime in default timezone\n</code></pre>"},{"location":"serializers.html#as_dict","title":"as_dict","text":"<p>Converts objects to dictionary using JSONEncoder:</p> <pre><code>from drf_kit.serializers import as_dict\n\n# Convert complex objects to dict\ndata = {\n    'date': datetime(2023, 1, 1, 12, 0, 0, tzinfo=UTC),\n    'price': Decimal('10.99'),\n    'file': user.avatar\n}\nresult = as_dict(data)\n# {\n#     'date': '2023-01-01T12:00:00Z',\n#     'price': '10.99',\n#     'file': '/media/avatars/user.jpg'\n# }\n</code></pre>"},{"location":"serializers.html#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>BaseModelSerializer</code> when working with models that inherit from BaseModel</li> <li>Prefer <code>ForeignKeyField</code> over raw <code>PrimaryKeyRelatedField</code> for better validation</li> <li>Use <code>JSONEncoder</code> when dealing with complex Python objects that need serialization</li> <li>Consider security implications when exposing foreign keys and file fields</li> <li>Always use <code>assure_tz</code> when handling datetime objects</li> <li>Use <code>as_str</code> for consistent string representation</li> <li>Leverage <code>as_dict</code> for complex object serialization</li> </ol> <p>For more detailed information about specific serializer features and advanced usage, refer to the source code documentation.</p>"},{"location":"signals.html","title":"Signals","text":"<p>DRF Toolkit provides a way to temporarily disable Django signals using the <code>UnplugSignal</code> context manager.</p>"},{"location":"signals.html#unplugsignal","title":"UnplugSignal","text":"<p>The <code>UnplugSignal</code> class allows you to temporarily disconnect a specific signal from a model. This is particularly useful in testing scenarios or when you need to perform operations without triggering certain signals.</p>"},{"location":"signals.html#usage","title":"Usage","text":"<pre><code>from django.db.models.signals import post_save\nfrom drf_kit.signals import UnplugSignal\n\n# Create an UnplugSignal instance\nunplugged = UnplugSignal(\n    signal=post_save,              # The Django signal to disconnect\n    func=my_signal_handler,        # The signal handler function\n    model=MyModel,                 # The sender model\n    dispatch_uid=None              # Optional dispatch_uid if used in signal connection\n)\n\n# Use as a context manager\nwith unplugged:\n    # Inside this block, the signal is disconnected\n    instance.save()  # This won't trigger the signal\n\n# After the block, the signal is automatically reconnected\ninstance.save()  # This will trigger the signal\n</code></pre>"},{"location":"signals.html#example","title":"Example","text":"<p>Here's a practical example showing how to use <code>UnplugSignal</code> in a test case:</p> <pre><code>from django.db.models.signals import post_save\nfrom drf_kit.signals import UnplugSignal\n\ndef test_signal_handling():\n    # Create an instance that would normally trigger a signal\n    instance = MyModel.objects.create()  # Signal is triggered\n\n    # Temporarily disable the signal\n    with UnplugSignal(\n        signal=post_save,\n        func=notification_handler,\n        model=MyModel\n    ):\n        instance.status = 'updated'\n        instance.save()  # Signal is not triggered\n\n    instance.status = 'final'\n    instance.save()  # Signal is triggered again\n</code></pre> <p>The signal is automatically reconnected when exiting the context manager, ensuring that your signal handling returns to normal operation after the required temporary disconnection.</p>"},{"location":"storage.html","title":"Storage Utilities","text":"<p>DRF Toolkit provides storage utilities to help manage file storage paths and naming conventions in your Django applications.</p>"},{"location":"storage.html#basedatastoragepath","title":"BaseDataStoragePath","text":"<p>The <code>BaseDataStoragePath</code> class provides utilities for handling file storage paths and file naming. It's particularly useful when you need consistent file naming conventions and unique file paths in your storage system.</p>"},{"location":"storage.html#features","title":"Features","text":"<ul> <li>Automatic unique file naming using UUID</li> <li>File extension handling</li> <li>Flexible path building</li> <li>Support for both model instances and dictionaries</li> </ul>"},{"location":"storage.html#basic-usage","title":"Basic Usage","text":"<pre><code>from drf_kit.storage import BaseDataStoragePath\n\n# Rename a file with unique suffix\nnew_filename = BaseDataStoragePath.rename(\n    filename=\"document.pdf\",\n    unique=True\n)\n# Result: document_550e8400-e29b-41d4-a716-446655440000.pdf\n\n# Rename with custom name\nnew_filename = BaseDataStoragePath.rename(\n    filename=\"document.pdf\",\n    new_name=\"contract\",\n    unique=True\n)\n# Result: contract_550e8400-e29b-41d4-a716-446655440000.pdf\n</code></pre>"},{"location":"storage.html#file-extension-handling","title":"File Extension Handling","text":"<p>The class handles file extensions intelligently:</p> <pre><code># With existing extension\nfilename = BaseDataStoragePath.rename(\n    filename=\"document.pdf\",\n    new_name=\"contract\"\n)\n# Result: contract.pdf\n\n# With default extension\nfilename = BaseDataStoragePath.rename(\n    filename=\"document\",\n    new_name=\"contract\",\n    default_extension=\"txt\"\n)\n# Result: contract.txt\n\n# Without extension\nfilename = BaseDataStoragePath.rename(\n    filename=\"document\",\n    new_name=\"contract\"\n)\n# Result: contract (with warning log)\n</code></pre>"},{"location":"storage.html#custom-storage-path","title":"Custom Storage Path","text":"<p>You can extend the class for custom storage paths:</p> <pre><code>class UserAvatarStorage(BaseDataStoragePath):\n    @classmethod\n    def get_upload_path(cls, instance, filename):\n        user_id = cls._get_pk(instance)\n        new_filename = cls.rename(filename, unique=True)\n        return f\"avatars/{user_id}/{new_filename}\"\n\n# Usage with model\nclass UserProfile(models.Model):\n    avatar = models.ImageField(\n        upload_to=UserAvatarStorage.get_upload_path\n    )\n</code></pre>"},{"location":"storage.html#primary-key-handling","title":"Primary Key Handling","text":"<p>The class handles primary keys for both model instances and dictionaries:</p> <pre><code># With model instance\nprofile = UserProfile.objects.get(id=1)\npk = BaseDataStoragePath._get_pk(profile)  # Returns \"1\"\n\n# With dictionary\ndata = {\"id\": \"123\"}\npk = BaseDataStoragePath._get_pk(data)  # Returns \"123\"\n\n# With new instance (generates UUID)\nnew_profile = UserProfile()\npk = BaseDataStoragePath._get_pk(new_profile)  # Returns UUID string\n</code></pre>"},{"location":"storage.html#best-practices","title":"Best Practices","text":"<ol> <li>Use unique filenames when storing user-uploaded files to prevent collisions</li> <li>Create custom storage classes for different types of files (e.g., avatars, documents)</li> <li>Always handle file extensions appropriately</li> <li>Consider implementing cleanup methods for old files</li> <li>Use the storage utilities with Django's file fields for consistent handling</li> </ol>"},{"location":"testing.html","title":"Testing","text":"<p>DRF Toolkit provides a comprehensive testing framework through the <code>BaseApiTest</code> class, which extends Django REST framework's <code>APITransactionTestCase</code>. This class offers a wide range of testing utilities specifically designed for API testing.</p>"},{"location":"testing.html#base-api-test-class","title":"Base API Test Class","text":"<p>The <code>BaseApiTest</code> class is the foundation for API testing in DRF Toolkit. To use it, extend your test class from <code>BaseApiTest</code>:</p> <pre><code>from drf_kit.tests import BaseApiTest\n\nclass MyAPITest(BaseApiTest):\n    def test_my_api(self):\n        response = self.client.get('/api/endpoint/')\n        self.assertResponse(status.HTTP_200_OK, response)\n</code></pre>"},{"location":"testing.html#cache-testing","title":"Cache Testing","text":""},{"location":"testing.html#real-cache-context-manager","title":"Real Cache Context Manager","text":"<p>The <code>real_cache</code> context manager allows testing with a local memory cache:</p> <pre><code>def test_with_cache(self):\n    with self.real_cache():\n        # Test code that uses cache\n        response = self.client.get('/api/cached-data/')\n        self.assertResponse(status.HTTP_200_OK, response)\n</code></pre>"},{"location":"testing.html#cache-lock-testing","title":"Cache Lock Testing","text":"<p>Test cache locks using the <code>patch_cache_lock</code> context manager:</p> <pre><code>def test_locked_operation(self):\n    with self.patch_cache_lock() as lock:\n        # Execute code that uses cache lock\n        result = some_locked_operation()\n\n        # Assert lock was called with specific parameters\n        lock.assert_called_with(\"lock_name\", timeout=60)\n</code></pre>"},{"location":"testing.html#migration-testing","title":"Migration Testing","text":"<p>Check for pending migrations using <code>assertNoPendingMigration</code>:</p> <pre><code>def test_migrations(self):\n    self.assertNoPendingMigration(\"my_app\")\n</code></pre>"},{"location":"testing.html#file-path-testing","title":"File Path Testing","text":"<p>Validate UUID-based file paths using <code>assertUUIDFilePath</code>:</p> <pre><code>def test_file_path(self):\n    file_path = \"uploads/123/image_550e8400-e29b-41d4-a716-446655440000.jpg\"\n    self.assertUUIDFilePath(\n        prefix=\"uploads\",\n        pk=\"123\",\n        name=\"image\",\n        extension=\"jpg\",\n        file=file_path\n    )\n</code></pre>"},{"location":"testing.html#response-testing","title":"Response Testing","text":""},{"location":"testing.html#basic-response-assertions","title":"Basic Response Assertions","text":"<pre><code>def test_api_responses(self):\n    # Test list endpoint\n    response = self.client.get('/api/items/')\n    self.assertResponseList(\n        expected_items=[{'id': 1, 'name': 'Item 1'}],\n        response=response\n    )\n\n    # Test detail endpoint\n    response = self.client.get('/api/items/1/')\n    self.assertResponseDetail(\n        expected_item={'id': 1, 'name': 'Item 1'},\n        response=response\n    )\n\n    # Test create endpoint\n    response = self.client.post('/api/items/', {'name': 'New Item'})\n    self.assertResponseCreate(\n        expected_item={'id': 2, 'name': 'New Item'},\n        response=response\n    )\n\n    # Test update endpoint\n    response = self.client.put('/api/items/1/', {'name': 'Updated Item'})\n    self.assertResponseUpdate(\n        expected_item={'id': 1, 'name': 'Updated Item'},\n        response=response\n    )\n\n    # Test delete endpoint\n    response = self.client.delete('/api/items/1/')\n    self.assertResponseDelete(response)\n</code></pre>"},{"location":"testing.html#error-response-assertions","title":"Error Response Assertions","text":"<pre><code>def test_error_responses(self):\n    # Test bad request\n    response = self.client.post('/api/items/', {})\n    self.assertResponseBadRequest(response)\n\n    # Test method not allowed\n    response = self.client.put('/api/items/')\n    self.assertResponseNotAllowed(response)\n\n    # Test authentication required\n    response = self.client.get('/api/protected/')\n    self.assertResponseNotAuthenticated(response)\n\n    # Test permission denied\n    response = self.client.get('/api/admin-only/')\n    self.assertResponseForbidden(response)\n\n    # Test not found\n    response = self.client.get('/api/items/999/')\n    self.assertResponseNotFound(response)\n</code></pre>"},{"location":"testing.html#response-items-testing","title":"Response Items Testing","text":"<p>Test response items by their IDs:</p> <pre><code>def test_response_items(self):\n    items = [{'id': 1}, {'id': 2}, {'id': 3}]\n    response = self.client.get('/api/items/')\n    self.assertResponseItems(\n        expected_items=[1, 2, 3],  # Can be IDs, objects, or dictionaries\n        response=response,\n        response_key=\"results\",  # Default is \"results\"\n        pk_field=\"id\"  # Default is \"id\"\n    )\n</code></pre>"},{"location":"testing.html#advanced-response-matching","title":"Advanced Response Matching","text":"<p>The <code>assertResponseMatch</code> method provides powerful dictionary assertion capabilities:</p> <pre><code>def test_response_matching(self):\n    response = self.client.get('/api/complex-data/')\n\n    # Match exact values\n    self.assertResponseMatch(\n        expected={'name': 'Test', 'count': 42},\n        received=response.json()\n    )\n\n    # Use regex patterns\n    self.assertResponseMatch(\n        expected={'code': re.compile(r'^\\d{4}$')},\n        received={'code': '1234'}\n    )\n\n    # Match nested structures\n    self.assertResponseMatch(\n        expected={\n            'user': {\n                'id': 1,\n                'profile': {\n                    'age': 25\n                }\n            }\n        },\n        received=response.json()\n    )\n\n    # Match lists with specific order\n    self.assertResponseMatch(\n        expected={'items': [1, 2, 3]},\n        received={'items': [1, 2, 3]}\n    )\n\n    # Match sets (order doesn't matter)\n    self.assertResponseMatch(\n        expected={'tags': {'red', 'blue'}},\n        received={'tags': ['blue', 'red']}\n    )\n</code></pre> <p>The <code>assertResponseMatch</code> method provides detailed error messages when assertions fail, making it easier to identify mismatches in complex data structures.</p>"},{"location":"testing.html#best-practices","title":"Best Practices","text":"<ol> <li>Use the appropriate assertion method for each type of response</li> <li>Take advantage of the powerful <code>assertResponseMatch</code> for complex response validation</li> <li>Use cache testing utilities when working with cached views</li> <li>Always check for pending migrations in your tests</li> <li>Use the provided file path assertions when working with file uploads</li> </ol> <p>For more examples, check the test files in the project, particularly <code>test_app/tests/test_test_helpers.py</code>.</p>"},{"location":"views.html","title":"Views","text":"<p>DRF Toolkit provides enhanced viewsets with built-in support for multiple serializers, caching, searching, and bulk operations.</p>"},{"location":"views.html#modelviewset","title":"ModelViewSet","text":"<p>The base viewset class extends DRF's ModelViewSet with additional functionality for handling different serializers per action:</p> <pre><code>from drf_toolkit.views import ModelViewSet\n\nclass UserViewSet(ModelViewSet):\n    queryset = User.objects.all()\n\n    # Different serializers for different actions\n    serializer_class = UserDefaultSerializer\n    serializer_detail_class = UserDetailSerializer\n    serializer_create_class = UserCreateSerializer\n    serializer_update_class = UserUpdateSerializer\n    serializer_list_class = UserListSerializer\n\n    # Different querysets for different actions\n    queryset_detail = User.objects.select_related('profile')\n    queryset_create = User.objects.all()\n    queryset_update = User.objects.select_for_update()\n</code></pre>"},{"location":"views.html#key-features","title":"Key Features","text":"<ul> <li>Multiple serializers per action (detail, list, create, update)</li> <li>Different querysets per action</li> <li>Supports GET, POST, PATCH, DELETE methods</li> <li>Automatic response serializer selection</li> </ul>"},{"location":"views.html#variants","title":"Variants","text":""},{"location":"views.html#readonlymodelviewset","title":"ReadOnlyModelViewSet","text":"<p>For read-only endpoints that only allow GET operations:</p> <pre><code>from drf_toolkit.views import ReadOnlyModelViewSet\n\nclass UserViewSet(ReadOnlyModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    # Only GET, HEAD, OPTIONS methods allowed\n</code></pre>"},{"location":"views.html#nondestructivemodelviewset","title":"NonDestructiveModelViewSet","text":"<p>For endpoints that don't allow deletion:</p> <pre><code>from drf_toolkit.views import NonDestructiveModelViewSet\n\nclass UserViewSet(NonDestructiveModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    # Allows GET, POST, PATCH methods, but no DELETE\n</code></pre>"},{"location":"views.html#writeonlymodelviewset","title":"WriteOnlyModelViewSet","text":"<p>For write-only endpoints:</p> <pre><code>from drf_toolkit.views import WriteOnlyModelViewSet\n\nclass UserViewSet(WriteOnlyModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    # Only POST, PATCH, DELETE methods allowed\n</code></pre>"},{"location":"views.html#cached-viewsets","title":"Cached Viewsets","text":""},{"location":"views.html#cachedmodelviewset","title":"CachedModelViewSet","text":"<p>Adds automatic caching to list and retrieve operations:</p> <pre><code>from drf_toolkit.views import CachedModelViewSet\n\nclass UserViewSet(CachedModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n</code></pre> <p>Key features: - Automatic cache key generation based on:   - View ID   - URL parameters   - Query parameters   - Request headers - Respects Cache-Control headers - Adds X-Cache header (HIT/MISS) - Sets Expires header</p> <p>Variants: - CachedReadOnlyModelViewSet - CachedNonDestructiveModelViewSet</p>"},{"location":"views.html#cachedsearchablemodelviewset","title":"CachedSearchableModelViewSet","text":"<p>Implements searching capabilities using POST body with caching:</p> <pre><code>from drf_toolkit.views import CachedSearchableModelViewSet\n\nclass UserViewSet(CachedSearchableModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    search_fields = ['username', 'email']\n</code></pre> <p>Key features: - POST-based search endpoint - Cache keys include request body - All features from CachedModelViewSet</p> <p>Variants: - CachedSearchableReadOnlyModelViewSet - CachedSearchableNonDestructiveModelViewSet</p>"},{"location":"views.html#additional-mixins","title":"Additional Mixins","text":""},{"location":"views.html#upsertmixin","title":"UpsertMixin","text":"<p>Handles duplicate records by updating instead of creating:</p> <pre><code>from drf_toolkit.views import ModelViewSet, UpsertMixin\n\nclass UserViewSet(UpsertMixin, ModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n</code></pre> <p>Key features: - Catches IntegrityError and ConflictException - Updates existing record if found - Returns HTTP 200 for upserts - Handles both database and application-level conflicts</p>"},{"location":"views.html#bulkmixin","title":"BulkMixin","text":"<p>Enables bulk operations:</p> <pre><code>from drf_toolkit.views import ModelViewSet, BulkMixin\n\nclass UserViewSet(BulkMixin, ModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    serializer_list_class = UserBulkSerializer\n</code></pre> <p>Key features: - Enables bulk create and update - Uses list serializers for responses - Disables individual PATCH operations - Supports different serializers for bulk operations</p>"},{"location":"views.html#best-practices","title":"Best Practices","text":"<ol> <li>Choose the appropriate viewset variant for your use case</li> <li>Use specific serializers for different actions when needed</li> <li>Consider caching for read-heavy endpoints</li> <li>Use UpsertMixin when dealing with potential duplicates</li> <li>Implement BulkMixin for batch operations</li> <li>Set appropriate cache control headers for cached endpoints</li> <li>Use CachedSearchableModelViewSet for complex search operations</li> </ol>"},{"location":"views.html#nested-views","title":"Nested Views","text":"<p>DRF Toolkit provides specialized viewsets for handling nested resources (Many-to-One relationships):</p> <pre><code>from drf_toolkit.views import NestedModelViewSet\n\nclass CommentViewSet(NestedModelViewSet):\n    queryset = Comment.objects.all()\n    serializer_class = CommentSerializer\n\n    # Parent model configuration\n    queryset_nest = Post.objects.all()\n    lookup_url_kwarg_nest = 'post_pk'  # URL parameter for parent ID\n    lookup_field_nest = 'post_id'      # Field name in Comment model\n    serializer_field_nest = 'post'     # Field name in serializer\n</code></pre>"},{"location":"views.html#key-features_1","title":"Key Features","text":"<ul> <li>Automatically filters child objects by parent</li> <li>Validates parent-child relationships</li> <li>Injects parent relationship in create/update operations</li> <li>Handles URL-based parent identification</li> </ul>"},{"location":"views.html#variants_1","title":"Variants","text":"<ul> <li>NestedModelViewSet: Full CRUD operations for nested resources</li> <li>CachedNestedModelViewSet: Adds caching support</li> <li>ReadOnlyNestedModelViewSet: Read-only operations</li> <li>CachedReadOnlyNestedModelViewSet: Read-only with caching</li> </ul>"},{"location":"views.html#single-nested-views","title":"Single Nested Views","text":"<p>For handling One-to-One relationships, use Single Nested Views:</p> <pre><code>from drf_toolkit.views import SingleNestedModelViewSet\n\nclass ProfileViewSet(SingleNestedModelViewSet):\n    queryset = Profile.objects.all()\n    serializer_class = ProfileSerializer\n\n    queryset_nest = User.objects.all()\n    lookup_url_kwarg_nest = 'user_pk'\n    lookup_field_nest = 'user_id'\n</code></pre>"},{"location":"views.html#key-features_2","title":"Key Features","text":"<ul> <li>Enforces single object constraint</li> <li>Collection-level operations (no PK-based endpoints)</li> <li>PUT method to replace existing relationship</li> <li>Automatic conflict detection</li> </ul>"},{"location":"views.html#variants_2","title":"Variants","text":"<ul> <li>SingleNestedModelViewSet: Full CRUD operations</li> <li>CachedSingleNestedModelViewSet: Adds caching support</li> <li>ReadOnlySingleNestedModelViewSet: Read-only operations</li> <li>CachedReadOnlySingleNestedModelViewSet: Read-only with caching</li> </ul>"},{"location":"views.html#stats-view-mixin","title":"Stats View Mixin","text":"<p>The StatsViewMixin allows dynamic queryset mutation and serializer switching based on a query parameter:</p> <pre><code>from drf_toolkit.views import ModelViewSet, StatsViewMixin\n\nclass OrderViewSet(StatsViewMixin, ModelViewSet):\n    queryset = Order.objects.all()\n    serializer_class = OrderSerializer\n    serializer_stats_class = OrderStatsSerializer\n\n    def add_stats_to_queryset(self, queryset):\n        return queryset.annotate(\n            total_items=Count('items'),\n            total_value=Sum('items__price')\n        )\n</code></pre>"},{"location":"views.html#key-features_3","title":"Key Features","text":"<ul> <li>Activates with <code>?stats=1</code> query parameter</li> <li>Supports custom queryset annotations</li> <li>Uses different serializer for stats view</li> <li>Preserves original queryset ordering</li> </ul>"},{"location":"models/index.html","title":"Models","text":"<p>DRF Toolkit provides enhanced model functionality through various base classes and mixins. Each model type serves a specific purpose and can be combined with others to create more complex functionality.</p>"},{"location":"models/index.html#available-models","title":"Available Models","text":""},{"location":"models/index.html#base-models","title":"Base Models","text":"<ul> <li>Base Models - Core functionality and timestamp tracking</li> <li>Diff Models - Track field changes in models</li> </ul>"},{"location":"models/index.html#feature-models","title":"Feature Models","text":"<ul> <li>Availability Models - Time-based availability management</li> <li>File Models - File handling and storage</li> <li>Inheritance Models - Model inheritance capabilities</li> <li>Ordered Models - Ordered item management</li> <li>Soft Delete Models - Soft deletion functionality</li> </ul>"},{"location":"models/index.html#combined-models","title":"Combined Models","text":"<p>For more complex use cases, these models can be combined. See Model Combinations for examples and best practices.</p>"},{"location":"models/index.html#best-practices","title":"Best Practices","text":"<ol> <li>Always inherit from the appropriate base model for your use case</li> <li>Use the provided model managers for consistent behavior</li> <li>Consider using soft delete when data history is important</li> <li>Leverage the diff tracking for audit logs and change tracking</li> <li>Combine models thoughtfully to avoid complexity</li> </ol> <p>For detailed documentation on each model type, click the respective links above.</p>"},{"location":"models/availability.html","title":"Availability Models","text":"<p>The Availability Models in DRF Toolkit provide functionality for managing time-based availability of objects through a specialized manager. This is particularly useful for scenarios where you need to track when something is available, such as room bookings, event schedules, or time-limited resources.</p>"},{"location":"models/availability.html#features","title":"Features","text":"<ul> <li>Specialized manager for time-based queries (past, current, future)</li> <li>Point-in-time availability checking with timezone support</li> <li>Comprehensive overlap detection for scheduling conflicts</li> <li>Support for open-ended ranges (null start/end dates)</li> <li>Efficient query methods for common availability patterns</li> <li>Automatic validation of date ranges</li> <li>Built-in timezone handling</li> </ul>"},{"location":"models/availability.html#models","title":"Models","text":""},{"location":"models/availability.html#availabilitymodel","title":"AvailabilityModel","text":"<p>The base model for time-based availability tracking.</p> <pre><code>from drf_kit.models import AvailabilityModel\n\nclass RoomBooking(AvailabilityModel):\n    room_number = models.CharField(max_length=100)\n    description = models.TextField()\n</code></pre>"},{"location":"models/availability.html#fields","title":"Fields","text":"<ul> <li><code>starts_at</code> (DateTimeField, optional): When the availability period starts</li> <li><code>ends_at</code> (DateTimeField, optional): When the availability period ends</li> </ul> <p>Both fields can be null, allowing for open-ended ranges: - If both are null: Always available - If only starts_at is null: Available until ends_at - If only ends_at is null: Available from starts_at onwards - If both are set: Available during the specified period</p>"},{"location":"models/availability.html#model-properties","title":"Model Properties","text":"<p>The AvailabilityModel provides properties to check its current state:</p> <ul> <li><code>is_past</code>: True if the availability period has ended</li> <li><code>is_current</code>: True if currently available</li> <li><code>is_future</code>: True if the availability period hasn't started yet</li> </ul> <p>These properties automatically handle timezone-aware comparisons and null values appropriately.</p>"},{"location":"models/availability.html#query-methods","title":"Query Methods","text":"<p>The AvailabilityManager provides specialized methods for querying objects based on their availability state:</p>"},{"location":"models/availability.html#time-based-queries","title":"Time-based Queries","text":"<pre><code># Get past availabilities (ended before now)\nRoomBooking.objects.past()\n\n# Get current availabilities (active now)\nRoomBooking.objects.current()\n\n# Get future availabilities (starts after now)\nRoomBooking.objects.future()\n\n# Query with specific datetime\nspecific_date = timezone.now() + timedelta(days=7)\nRoomBooking.objects.current(at=specific_date)\n</code></pre>"},{"location":"models/availability.html#overlap-detection","title":"Overlap Detection","text":"<p>The manager provides a powerful method to find objects with overlapping availability periods:</p> <pre><code># Find bookings that overlap with a given period\nbooking = RoomBooking(\n    starts_at=timezone.now(),\n    ends_at=timezone.now() + timedelta(hours=2)\n)\noverlapping = RoomBooking.objects.same_availability_of(booking)\n\n# Handles various overlap scenarios:\n# - Complete overlap (one range contains another)\n# - Partial overlap (ranges intersect)\n# - Open-ended ranges (null starts_at or ends_at)\n</code></pre> <p>The <code>same_availability_of</code> method is particularly useful for: - Checking for scheduling conflicts - Finding concurrent availabilities - Validating time slot availability</p>"},{"location":"models/availability.html#validation","title":"Validation","text":"<p>The model automatically validates that <code>ends_at</code> is after <code>starts_at</code> when both are provided:</p> <pre><code># This will raise IntegrityError\nbooking = RoomBooking.objects.create(\n    starts_at=timezone.now(),\n    ends_at=timezone.now() - timedelta(days=1)\n)\n</code></pre>"},{"location":"models/availability.html#usage-examples","title":"Usage Examples","text":""},{"location":"models/availability.html#basic-usage","title":"Basic Usage","text":"<pre><code>from django.utils import timezone\nfrom datetime import timedelta\n\n# Create a booking for tomorrow\ntomorrow = timezone.now() + timedelta(days=1)\nbooking = RoomBooking.objects.create(\n    room_number=\"101\",\n    starts_at=tomorrow,\n    ends_at=tomorrow + timedelta(hours=2)\n)\n\n# Check availability state\nbooking.is_future  # True\nbooking.is_current  # False\nbooking.is_past  # False\n</code></pre>"},{"location":"models/availability.html#open-ended-ranges","title":"Open-ended Ranges","text":"<pre><code># Always available\nRoomBooking.objects.create(\n    room_number=\"102\",\n    starts_at=None,\n    ends_at=None\n)\n\n# Available until a specific time\nRoomBooking.objects.create(\n    room_number=\"103\",\n    starts_at=None,\n    ends_at=timezone.now() + timedelta(days=30)\n)\n\n# Available from a specific time onwards\nRoomBooking.objects.create(\n    room_number=\"104\",\n    starts_at=timezone.now(),\n    ends_at=None\n)\n</code></pre>"},{"location":"models/availability.html#conflict-detection","title":"Conflict Detection","text":"<pre><code># Check if a new booking conflicts with existing ones\nnew_booking = RoomBooking(\n    room_number=\"101\",\n    starts_at=timezone.now(),\n    ends_at=timezone.now() + timedelta(hours=1)\n)\n\nconflicts = RoomBooking.objects.same_availability_of(new_booking)\nif conflicts.exists():\n    print(\"This time slot is already booked!\")\n</code></pre>"},{"location":"models/availability.html#best-practices","title":"Best Practices","text":"<ol> <li>Always use timezone-aware datetime objects</li> <li>Consider using open-ended ranges for permanent or indefinite availability</li> <li>Use <code>same_availability_of</code> for conflict detection instead of manual comparisons</li> <li>Leverage manager methods (<code>current()</code>, <code>past()</code>, <code>future()</code>) for time-based filtering</li> <li>Use the <code>at</code> parameter for point-in-time availability checks</li> <li>Remember that null values in <code>starts_at</code> or <code>ends_at</code> represent open-ended ranges</li> <li>Consider implementing business logic around overlapping availabilities</li> </ol>"},{"location":"models/base.html","title":"Base Models","text":"<p>The Base Models in DRF Toolkit provide fundamental functionality that all other models build upon. These models include essential features like automatic timestamps, change tracking, and file handling capabilities.</p>"},{"location":"models/base.html#basemodel","title":"BaseModel","text":"<p>The <code>BaseModel</code> is the foundation for all models in DRF Toolkit. It combines several mixins to provide a rich set of features while maintaining clean and organized code.</p> <pre><code>from drf_kit.models import BaseModel\n\nclass MyModel(BaseModel):\n    name = models.CharField(max_length=100)\n</code></pre>"},{"location":"models/base.html#features","title":"Features","text":""},{"location":"models/base.html#automatic-timestamps","title":"Automatic Timestamps","text":"<ul> <li><code>created_at</code>: Automatically set when the object is created</li> <li><code>updated_at</code>: Automatically updated whenever the object is saved</li> </ul>"},{"location":"models/base.html#default-configuration","title":"Default Configuration","text":"<ul> <li>Ordering by most recently updated (<code>-updated_at</code>)</li> <li>Automatic indexing on <code>updated_at</code> field</li> <li>Latest object determination based on <code>updated_at</code></li> </ul>"},{"location":"models/base.html#change-tracking","title":"Change Tracking","text":"<p>BaseModel includes the ModelDiffMixin (see Diff Models for details) which provides:</p> <pre><code># Create and modify an object\nobj = MyModel.objects.create(name=\"Original\")\nobj.name = \"Modified\"\n\n# Check what changed\nobj._has_changed  # True\nobj._changed_fields  # ['name']\nobj._diff  # {'name': ('Original', 'Modified')}\n\n# Save changes\nobj.save()  # Resets the change tracking\nobj._has_changed  # False\n</code></pre>"},{"location":"models/base.html#file-handling","title":"File Handling","text":"<p>BaseModel includes BoundedFileMixin for enhanced file field management (see File Models for details).</p>"},{"location":"models/base.html#usage-examples","title":"Usage Examples","text":""},{"location":"models/base.html#basic-usage","title":"Basic Usage","text":"<pre><code>from drf_kit.models import BaseModel\nfrom django.db import models\n\nclass Product(BaseModel):\n    name = models.CharField(max_length=100)\n    price = models.DecimalField(max_digits=10, decimal_places=2)\n\n# Create a product\nproduct = Product.objects.create(\n    name=\"Widget\",\n    price=9.99\n)\n\n# Automatic timestamps\nprint(product.created_at)  # When the product was created\nprint(product.updated_at)  # When the product was last modified\n\n# Get admin URL\nadmin_url = product.admin_edit_url()\n</code></pre>"},{"location":"models/base.html#querying","title":"Querying","text":"<pre><code># Get latest products\nlatest_products = Product.objects.all()  # Automatically ordered by -updated_at\n\n# Get single latest product\nlatest_product = Product.objects.latest()\n\n# Use the timestamp index\nrecent_products = Product.objects.filter(\n    updated_at__gte=timezone.now() - timedelta(days=7)\n)\n</code></pre>"},{"location":"models/base.html#best-practices","title":"Best Practices","text":"<ol> <li>Always inherit from BaseModel instead of models.Model for consistent functionality</li> <li>Use the provided change tracking methods instead of manual state comparison</li> <li>Leverage the automatic timestamps for tracking object history</li> <li>Take advantage of the default ordering and indexes for common query patterns</li> <li>Use the admin_edit_url() method for admin panel integration</li> </ol>"},{"location":"models/combinations.html","title":"Model Combinations","text":"<p>DRF Toolkit provides several pre-built model combinations for common use cases, as well as the ability to create custom combinations of model features.</p>"},{"location":"models/combinations.html#available-combinations","title":"Available Combinations","text":""},{"location":"models/combinations.html#softdeleteinheritancemodel","title":"SoftDeleteInheritanceModel","text":"<p>Combines soft deletion with inheritance tracking:</p> <pre><code>from drf_kit.models import SoftDeleteInheritanceModel\n\nclass Character(SoftDeleteInheritanceModel):\n    name = models.CharField(max_length=100)\n\nclass Wizard(Character):\n    magic_power = models.IntegerField()\n\nclass Warrior(Character):\n    strength = models.IntegerField()\n\n# Creates a wizard with type tracking\nwizard = Wizard.objects.create(name=\"Merlin\", magic_power=100)\nprint(wizard.type)  # \"wizard\"\n\n# Soft deletes the wizard\nwizard.delete()\nprint(wizard.is_deleted)  # True\n\n# Query includes type information\nCharacter.objects.filter(type=\"wizard\")  # Excludes deleted\nCharacter.objects.all_with_deleted().filter(type=\"wizard\")  # Includes deleted\n</code></pre>"},{"location":"models/combinations.html#softdeleteavailabilitymodel","title":"SoftDeleteAvailabilityModel","text":"<p>Combines soft deletion with time-based availability:</p> <pre><code>from drf_kit.models import SoftDeleteAvailabilityModel\n\nclass Event(SoftDeleteAvailabilityModel):\n    name = models.CharField(max_length=100)\n    location = models.CharField(max_length=100)\n\n# Create an event with availability\nevent = Event.objects.create(\n    name=\"Magic Show\",\n    starts_at=timezone.now(),\n    ends_at=timezone.now() + timedelta(hours=2)\n)\n\n# Check availability\nprint(event.is_current)  # True if within time range\nprint(event.is_deleted)  # False\n\n# Soft delete\nevent.delete()\nprint(event.is_deleted)  # True\n\n# Queries respect both deletion and availability\nEvent.objects.current()  # Active and current events\nEvent.objects.all_with_deleted().future()  # All future events, including deleted\n</code></pre>"},{"location":"models/combinations.html#softdeleteinheritanceorderedmodel","title":"SoftDeleteInheritanceOrderedModel","text":"<p>Combines soft deletion, inheritance tracking, and ordering:</p> <pre><code>from drf_kit.models import SoftDeleteInheritanceOrderedModel\n\nclass Spell(SoftDeleteInheritanceOrderedModel):\n    name = models.CharField(max_length=100)\n\nclass AttackSpell(Spell):\n    damage = models.IntegerField()\n\nclass DefenseSpell(Spell):\n    shield = models.IntegerField()\n\n# Creates spells with automatic ordering\nattack1 = AttackSpell.objects.create(name=\"Fireball\", damage=100)  # order=0\nattack2 = AttackSpell.objects.create(name=\"Lightning\", damage=80)  # order=1\ndefense1 = DefenseSpell.objects.create(name=\"Shield\", shield=50)   # order=0\n\n# Ordering is maintained per type\nprint(attack1.order)  # 0\nprint(attack2.order)  # 1\nprint(defense1.order) # 0\n\n# Soft delete maintains order\nattack1.delete()\nnew_attack = AttackSpell.objects.create(name=\"Ice\", damage=90)  # order=1\nprint(attack2.order)  # 0 (reordered)\n</code></pre>"},{"location":"models/combinations.html#creating-custom-combinations","title":"Creating Custom Combinations","text":"<p>You can create custom combinations by inheriting from multiple mixins:</p> <pre><code>from drf_kit.models import (\n    BaseModel,\n    SoftDeleteModelMixin,\n    OrderedModelMixin,\n    AvailabilityModelMixin\n)\n\nclass CustomModel(\n    SoftDeleteModelMixin,\n    OrderedModelMixin,\n    AvailabilityModelMixin,\n    BaseModel\n):\n    class Meta:\n        abstract = True\n        ordering = ('order', '-updated_at')\n        indexes = (\n            SoftDeleteModelMixin.Meta.indexes +\n            OrderedModelMixin.Meta.indexes +\n            AvailabilityModelMixin.Meta.indexes +\n            BaseModel.Meta.indexes\n        )\n</code></pre>"},{"location":"models/combinations.html#best-practices","title":"Best Practices","text":"<ol> <li>Use pre-built combinations when they match your needs</li> <li>When creating custom combinations:</li> <li>Always include BaseModel last</li> <li>Combine Meta classes properly</li> <li>Merge indexes from all mixins</li> <li>Consider the order of mixins (affects method resolution)</li> <li>Test combined functionality thoroughly</li> <li>Document the features provided by your combinations</li> <li>Consider performance implications of multiple features</li> <li>Use the most specific combination that meets your needs</li> </ol>"},{"location":"models/combinations.html#feature-matrix","title":"Feature Matrix","text":"Model Type Soft Delete Inheritance Ordered Availability SoftDeleteInheritanceModel \u2713 \u2713 SoftDeleteAvailabilityModel \u2713 \u2713 SoftDeleteInheritanceOrderedModel \u2713 \u2713 \u2713 SoftDeleteOrderedModel \u2713 \u2713 InheritanceOrderedModel \u2713 \u2713"},{"location":"models/combinations.html#technical-considerations","title":"Technical Considerations","text":""},{"location":"models/combinations.html#method-resolution-order","title":"Method Resolution Order","text":"<p>When combining models, be aware of Python's method resolution order (MRO):</p> <pre><code>class CustomModel(SoftDeleteModelMixin, OrderedModelMixin, BaseModel):\n    pass\n\nprint(CustomModel.__mro__)\n# Shows the order in which methods are resolved\n</code></pre>"},{"location":"models/diff.html","title":"Diff Models","text":"<p>The Diff Models in DRF Toolkit provide functionality for tracking changes to model instances. This is particularly useful for audit logging, change history, and validation scenarios.</p>"},{"location":"models/diff.html#modeldiffmixin","title":"ModelDiffMixin","text":"<p>The <code>ModelDiffMixin</code> tracks changes to model fields by maintaining a snapshot of the initial state and comparing it with current values.</p> <pre><code>from drf_kit.models import BaseModel  # Includes ModelDiffMixin\n\nclass User(BaseModel):\n    name = models.CharField(max_length=100)\n    email = models.EmailField()\n</code></pre>"},{"location":"models/diff.html#features","title":"Features","text":"<ul> <li>Tracks changes to model fields</li> <li>Supports relationship fields</li> <li>Handles deferred fields (lazy loading)</li> <li>Automatic state reset after save</li> <li>Serializable diff format</li> </ul>"},{"location":"models/diff.html#properties-and-methods","title":"Properties and Methods","text":""},{"location":"models/diff.html#_has_changed","title":"<code>_has_changed</code>","text":"<p>Returns <code>True</code> if any field has changed from its initial state.</p> <pre><code>user = User.objects.create(name=\"John\", email=\"john@example.com\")\nuser.name = \"Johnny\"\nprint(user._has_changed)  # True\n</code></pre>"},{"location":"models/diff.html#_changed_fields","title":"<code>_changed_fields</code>","text":"<p>Returns a list of field names that have changed.</p> <pre><code>user.name = \"Johnny\"\nuser.email = \"johnny@example.com\"\nprint(user._changed_fields)  # ['name', 'email']\n</code></pre>"},{"location":"models/diff.html#_diff","title":"<code>_diff</code>","text":"<p>Returns a dictionary of changed fields with their original and new values.</p> <pre><code>user.name = \"Johnny\"\nprint(user._diff)  # {'name': ('John', 'Johnny')}\n</code></pre>"},{"location":"models/diff.html#_get_field_difffield_name","title":"<code>_get_field_diff(field_name)</code>","text":"<p>Returns the change tuple (old_value, new_value) for a specific field.</p> <pre><code>old_value, new_value = user._get_field_diff('name')\n</code></pre>"},{"location":"models/diff.html#state-management","title":"State Management","text":"<p>The initial state is captured when: 1. The object is instantiated 2. After a successful save 3. When refreshed from the database</p> <pre><code># Create a user\nuser = User.objects.create(name=\"John\")\nprint(user._has_changed)  # False\n\n# Modify the user\nuser.name = \"Johnny\"\nprint(user._has_changed)  # True\nprint(user._diff)  # {'name': ('John', 'Johnny')}\n\n# Save the user\nuser.save()\nprint(user._has_changed)  # False (state reset after save)\n</code></pre>"},{"location":"models/diff.html#relationship-fields","title":"Relationship Fields","text":"<p>For relationship fields, the mixin tracks the foreign key ID:</p> <pre><code>class Post(BaseModel):\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    title = models.CharField(max_length=100)\n\npost = Post.objects.create(author=user, title=\"Hello\")\npost.author = other_user\nprint(post._diff)  # {'author_id': (1, 2)}\n</code></pre>"},{"location":"models/diff.html#deferred-fields","title":"Deferred Fields","text":"<p>The mixin handles deferred fields (from <code>defer()</code> or <code>only()</code> queries) by lazy loading them when needed:</p> <pre><code># Only load specific fields\nuser = User.objects.only('name').get(id=1)\nprint(user.email)  # Triggers lazy loading\nprint(user._diff)  # Includes changes to all fields\n</code></pre>"},{"location":"models/diff.html#usage-examples","title":"Usage Examples","text":""},{"location":"models/diff.html#audit-logging","title":"Audit Logging","text":"<pre><code>class AuditedModel(BaseModel):\n    def save(self, *args, **kwargs):\n        if self._has_changed:\n            AuditLog.objects.create(\n                model=self.__class__.__name__,\n                object_id=self.pk,\n                changes=self._diff\n            )\n        super().save(*args, **kwargs)\n</code></pre>"},{"location":"models/diff.html#validation","title":"Validation","text":"<pre><code>class User(BaseModel):\n    def clean(self):\n        if 'email' in self._changed_fields:\n            # Validate email change\n            validate_email_change(self._get_field_diff('email'))\n</code></pre>"},{"location":"models/diff.html#change-detection","title":"Change Detection","text":"<pre><code>def update_user(user, **changes):\n    for field, value in changes.items():\n        setattr(user, field, value)\n\n    if user._has_changed:\n        user.save()\n        notify_user_changed(user, user._diff)\n    return user\n</code></pre>"},{"location":"models/diff.html#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>_has_changed</code> for conditional logic based on changes</li> <li>Access specific field changes with <code>_get_field_diff()</code> instead of parsing <code>_diff</code></li> <li>Remember that <code>save()</code> resets the change tracking</li> <li>Consider performance implications when using with deferred fields</li> <li>Use the change tracking for audit logs and validation scenarios</li> </ol>"},{"location":"models/file.html","title":"File Models","text":"<p>The File Models in DRF Toolkit provide enhanced file handling capabilities for Django models. The functionality is implemented through the <code>BoundedFileMixin</code>, which is included in <code>BaseModel</code>.</p>"},{"location":"models/file.html#boundedfilemixin","title":"BoundedFileMixin","text":"<p>The <code>BoundedFileMixin</code> automatically manages file names and storage operations for models with file fields.</p> <pre><code>from drf_kit.models import BaseModel\n\nclass Document(BaseModel):  # Includes BoundedFileMixin\n    file = models.FileField(upload_to='documents/')\n    title = models.CharField(max_length=100)\n</code></pre>"},{"location":"models/file.html#features","title":"Features","text":"<ul> <li>Automatic file name management</li> <li>Support for custom storage backends</li> <li>Efficient file operations</li> <li>Proper file cleanup</li> <li>Handles multiple file fields</li> </ul>"},{"location":"models/file.html#file-management","title":"File Management","text":"<p>The mixin manages files during model creation:</p> <ol> <li>Generates proper file names using the field's <code>upload_to</code> and file name generator</li> <li>Moves files to their final location</li> <li>Updates file references in the model</li> <li>Handles cleanup of temporary files</li> </ol>"},{"location":"models/file.html#storage-backend-support","title":"Storage Backend Support","text":"<p>The mixin works with different storage backends:</p> <pre><code>class Document(BaseModel):\n    # Local filesystem storage\n    local_file = models.FileField(\n        upload_to='local/',\n        storage=FileSystemStorage()\n    )\n\n    # Custom storage backend\n    cloud_file = models.FileField(\n        upload_to='cloud/',\n        storage=CustomStorageBackend()\n    )\n</code></pre>"},{"location":"models/file.html#storage-operations","title":"Storage Operations","text":"<ul> <li>Uses <code>move</code> operation when available (more efficient)</li> <li>Falls back to save/delete for basic storage backends</li> <li>Properly closes file handles after operations</li> </ul>"},{"location":"models/file.html#usage-examples","title":"Usage Examples","text":""},{"location":"models/file.html#basic-file-handling","title":"Basic File Handling","text":"<pre><code>class UserDocument(BaseModel):\n    file = models.FileField(upload_to='user_docs/')\n    user = models.ForeignKey(User, on_delete=models.CASCADE)\n\n# File will be automatically managed\ndoc = UserDocument.objects.create(\n    file=uploaded_file,\n    user=user\n)\n</code></pre>"},{"location":"models/file.html#custom-file-naming","title":"Custom File Naming","text":"<pre><code>def generate_filename(instance, filename):\n    return f\"documents/{instance.user.id}/{filename}\"\n\nclass Document(BaseModel):\n    file = models.FileField(upload_to=generate_filename)\n</code></pre>"},{"location":"models/file.html#multiple-file-fields","title":"Multiple File Fields","text":"<pre><code>class MediaItem(BaseModel):\n    image = models.ImageField(upload_to='images/')\n    document = models.FileField(upload_to='documents/')\n    attachment = models.FileField(upload_to='attachments/')\n\n    # All files will be properly managed\n</code></pre>"},{"location":"models/file.html#custom-storage-backend","title":"Custom Storage Backend","text":"<pre><code>class S3Document(BaseModel):\n    file = models.FileField(\n        upload_to='documents/',\n        storage=S3Boto3Storage()\n    )\n\n    # Files will be efficiently moved in S3\n    # if the storage backend supports move operations\n</code></pre>"},{"location":"models/file.html#best-practices","title":"Best Practices","text":"<ol> <li>Always use the mixin (through BaseModel) when working with file fields</li> <li>Implement proper file name generators for organized storage</li> <li>Use storage backends that support move operations for better performance</li> <li>Consider implementing file cleanup on model deletion if needed</li> <li>Handle file operations in transactions when appropriate</li> </ol>"},{"location":"models/file.html#technical-details","title":"Technical Details","text":""},{"location":"models/file.html#file-operations","title":"File Operations","text":"<p>The mixin performs these steps during model creation:</p> <ol> <li>Saves the model instance first</li> <li>Identifies all FileField instances</li> <li>For each file:</li> <li>Generates the final filename</li> <li>Moves/copies the file if needed</li> <li>Updates the file reference</li> <li>Saves the model again if files were modified</li> </ol>"},{"location":"models/file.html#storage-backend-integration","title":"Storage Backend Integration","text":"<pre><code># With move support\nif hasattr(file.storage, \"move\"):\n    file.storage.move(old_file, new_file)\nelse:\n    # Fallback for basic storage\n    file.storage.save(new_file, file)\n    file.storage.delete(old_file)\n</code></pre> <p>This ensures compatibility with both simple and advanced storage backends.</p>"},{"location":"models/inheritance.html","title":"Inheritance Models","text":"<p>The Inheritance Models in DRF Toolkit provide enhanced support for Django's model inheritance by automatically tracking model types and providing proper querying capabilities.</p>"},{"location":"models/inheritance.html#inheritancemodel","title":"InheritanceModel","text":"<p>The <code>InheritanceModel</code> is designed to work with Django's multi-table inheritance, automatically tracking the concrete model type for each instance.</p> <pre><code>from drf_kit.models import InheritanceModel\n\nclass Tale(InheritanceModel):\n    title = models.CharField(max_length=100)\n    description = models.TextField()\n\nclass DarkTale(Tale):\n    dark_level = models.IntegerField()\n\nclass HappyTale(Tale):\n    happiness_level = models.IntegerField()\n</code></pre>"},{"location":"models/inheritance.html#features","title":"Features","text":"<ul> <li>Automatic type tracking</li> <li>Type field for model identification</li> <li>Seamless integration with Django's ORM</li> <li>Compatible with other mixins</li> <li>Pre-save signal handling</li> </ul>"},{"location":"models/inheritance.html#type-tracking","title":"Type Tracking","text":"<p>The model automatically maintains a <code>type</code> field that stores the concrete model class name:</p> <pre><code># Creating instances\ntale = Tale.objects.create(title=\"Generic Tale\")\ndark_tale = DarkTale.objects.create(title=\"Dark Story\", dark_level=666)\nhappy_tale = HappyTale.objects.create(title=\"Happy Story\", happiness_level=100)\n\n# Type field is automatically set\nprint(tale.type)  # \"tale\"\nprint(dark_tale.type)  # \"darktale\"\nprint(happy_tale.type)  # \"happytale\"\n</code></pre>"},{"location":"models/inheritance.html#querying","title":"Querying","text":"<p>You can query through the parent model to get all instances, including child models:</p> <pre><code># Get all tales (including DarkTale and HappyTale instances)\nall_tales = Tale.objects.all()\n\n# Filter specific types\ndark_tales = Tale.objects.filter(type=\"darktale\")\nhappy_tales = Tale.objects.filter(type=\"happytale\")\n</code></pre>"},{"location":"models/inheritance.html#usage-examples","title":"Usage Examples","text":""},{"location":"models/inheritance.html#basic-inheritance","title":"Basic Inheritance","text":"<pre><code>from drf_kit.models import InheritanceModel\n\nclass Spell(InheritanceModel):\n    name = models.CharField(max_length=100)\n    power = models.IntegerField()\n\nclass CombatSpell(Spell):\n    damage = models.IntegerField()\n\nclass HealingSpell(Spell):\n    healing_power = models.IntegerField()\n\n# Create instances\ncombat_spell = CombatSpell.objects.create(\n    name=\"Fireball\",\n    power=50,\n    damage=100\n)\n\nhealing_spell = HealingSpell.objects.create(\n    name=\"Heal\",\n    power=30,\n    healing_power=75\n)\n\n# Query through parent\nall_spells = Spell.objects.all()\n</code></pre>"},{"location":"models/inheritance.html#combining-with-other-mixins","title":"Combining with Other Mixins","text":"<p>The inheritance model works seamlessly with other mixins:</p> <pre><code>from drf_kit.models import SoftDeleteInheritanceModel\n\nclass Character(SoftDeleteInheritanceModel):\n    name = models.CharField(max_length=100)\n\nclass Wizard(Character):\n    magic_power = models.IntegerField()\n\nclass Warrior(Character):\n    strength = models.IntegerField()\n\n# Supports both inheritance and soft delete\nwizard = Wizard.objects.create(name=\"Merlin\", magic_power=100)\nwizard.delete()  # Soft delete\n</code></pre>"},{"location":"models/inheritance.html#type-based-logic","title":"Type-Based Logic","text":"<pre><code>class SpellEffect:\n    def apply(self, spell):\n        if spell.type == \"combatspell\":\n            self.apply_combat_effect(spell)\n        elif spell.type == \"healingspell\":\n            self.apply_healing_effect(spell)\n</code></pre>"},{"location":"models/inheritance.html#technical-details","title":"Technical Details","text":""},{"location":"models/inheritance.html#type-field","title":"Type Field","text":"<pre><code>class InheritanceModelMixin(models.Model):\n    type = models.CharField(max_length=100)\n\n    class Meta:\n        abstract = True\n</code></pre>"},{"location":"models/inheritance.html#automatic-type-setting","title":"Automatic Type Setting","text":"<p>The type is automatically set through a pre-save signal:</p> <pre><code>def assert_inherited_type(sender, instance, **kwargs):\n    instance.type = instance.__class__.__name__.lower()\n\n@classmethod\ndef __init_subclass__(cls, **kwargs):\n    super().__init_subclass__(**kwargs)\n    pre_save.connect(assert_inherited_type, cls)\n</code></pre>"},{"location":"models/inheritance.html#best-practices","title":"Best Practices","text":"<ol> <li>Use InheritanceModel for multi-table inheritance scenarios</li> <li>Let the type field be managed automatically</li> <li>Query through the parent model when you need all subtypes</li> <li>Combine with other mixins as needed (e.g., SoftDeleteInheritanceModel)</li> <li>Use the type field for type-specific logic rather than isinstance checks</li> </ol>"},{"location":"models/ordered.html","title":"Ordered Models","text":"<p>The Ordered Models in DRF Toolkit provide functionality for maintaining ordered collections of objects. This is particularly useful for scenarios like rankings, playlists, or any situation where items need to maintain a specific sequence.</p>"},{"location":"models/ordered.html#orderedmodel","title":"OrderedModel","text":"<p>The <code>OrderedModel</code> automatically manages the ordering of objects, ensuring a continuous sequence and providing methods for reordering.</p> <pre><code>from drf_kit.models import OrderedModel\n\nclass Playlist(OrderedModel):\n    name = models.CharField(max_length=100)\n    song = models.ForeignKey('Song', on_delete=models.CASCADE)\n</code></pre>"},{"location":"models/ordered.html#features","title":"Features","text":"<ul> <li>Automatic order management</li> <li>Continuous sequence maintenance</li> <li>Support for group-based ordering</li> <li>Reordering capabilities</li> <li>Index optimization</li> </ul>"},{"location":"models/ordered.html#order-field","title":"Order Field","text":"<p>The model includes an <code>order</code> field that maintains the sequence:</p> <pre><code>order = models.PositiveIntegerField(\n    db_index=True,\n    default=None,\n    null=True,\n    blank=True\n)\n</code></pre>"},{"location":"models/ordered.html#usage-examples","title":"Usage Examples","text":""},{"location":"models/ordered.html#basic-ordering","title":"Basic Ordering","text":"<pre><code># Items are automatically ordered as they're created\nfirst = Playlist.objects.create(name=\"First Song\", song=song1)\nsecond = Playlist.objects.create(name=\"Second Song\", song=song2)\nthird = Playlist.objects.create(name=\"Third Song\", song=song3)\n\nprint(first.order)   # 0\nprint(second.order)  # 1\nprint(third.order)   # 2\n\n# Get items in order\nplaylist = Playlist.objects.all()  # Ordered by 'order' field\n</code></pre>"},{"location":"models/ordered.html#group-based-ordering","title":"Group-Based Ordering","text":"<pre><code>class TournamentRanking(OrderedModel):\n    player = models.ForeignKey('Player', on_delete=models.CASCADE)\n    tournament = models.ForeignKey('Tournament', on_delete=models.CASCADE)\n    score = models.IntegerField()\n\n    class Meta:\n        ordering = ('tournament', 'order')\n\n# Each tournament has its own ordering\ntournament1_rank1 = TournamentRanking.objects.create(tournament=tournament1, player=player1)  # order=0\ntournament1_rank2 = TournamentRanking.objects.create(tournament=tournament1, player=player2)  # order=1\ntournament2_rank1 = TournamentRanking.objects.create(tournament=tournament2, player=player3)  # order=0\n</code></pre>"},{"location":"models/ordered.html#manual-reordering","title":"Manual Reordering","text":"<pre><code># Move an item to a specific position\nthird.order = 0\nthird.save()\n\n# Original order: [first(0), second(1), third(2)]\n# New order:      [third(0), first(1), second(2)]\n\n# Move to end (any large number works)\nfirst.order = 99\nfirst.save()\n\n# New order: [third(0), second(1), first(2)]\n</code></pre>"},{"location":"models/ordered.html#handling-deletions","title":"Handling Deletions","text":"<pre><code># Items are automatically reordered when one is deleted\nsecond.delete()\n\n# Original order: [third(0), second(1), first(2)]\n# New order:      [third(0), first(1)]\n</code></pre>"},{"location":"models/ordered.html#creating-at-specific-position","title":"Creating at Specific Position","text":"<pre><code># Insert at specific position\nnew_item = Playlist.objects.create(\n    name=\"New Song\",\n    song=song4,\n    order=1  # Insert at position 1\n)\n\n# Original order: [third(0), first(1)]\n# New order:      [third(0), new_item(1), first(2)]\n</code></pre>"},{"location":"models/ordered.html#technical-details","title":"Technical Details","text":""},{"location":"models/ordered.html#automatic-reordering","title":"Automatic Reordering","text":"<p>The model maintains a continuous sequence by: 1. Handling new items (append or insert) 2. Reordering on deletions 3. Managing manual position changes</p> <pre><code>def assert_order(sender, instance, **kwargs):\n    order = getattr(instance, instance.order_field_name)\n    group = list(instance.get_ordering_queryset().exclude(id=instance.pk))\n\n    if order is not None:\n        group.insert(max(0, order), instance)\n    else:\n        group.append(instance)\n\n    for index, obj in enumerate(group):\n        if obj.order != index:\n            obj.__class__.objects.filter(pk=obj.pk).update(order=index)\n</code></pre>"},{"location":"models/ordered.html#meta-configuration","title":"Meta Configuration","text":"<pre><code>class Meta:\n    abstract = True\n    ordering = ('order', '-updated_at')\n    indexes = [\n        models.Index(fields=['order']),\n    ]\n</code></pre>"},{"location":"models/ordered.html#best-practices","title":"Best Practices","text":"<ol> <li>Use OrderedModel when you need to maintain a specific sequence</li> <li>Let the order field be managed automatically when possible</li> <li>Use group-based ordering for separate sequences (e.g., by category, year)</li> <li>Consider performance implications when reordering large sets</li> <li>Use the built-in ordering in queries instead of manual sorting</li> <li>Remember that order values are zero-based</li> <li>Use database transactions when reordering multiple items</li> </ol>"},{"location":"models/soft_delete.html","title":"Soft Delete Models","text":"<p>The Soft Delete Models in DRF Toolkit provide functionality for marking records as deleted without physically removing them from the database. This is particularly useful for maintaining data history, implementing recycle bins, or handling complex relationships.</p>"},{"location":"models/soft_delete.html#softdeletemodel","title":"SoftDeleteModel","text":"<p>The <code>SoftDeleteModel</code> adds soft deletion capabilities to your models, maintaining a deletion timestamp and managing related objects.</p> <pre><code>from drf_kit.models import SoftDeleteModel\n\nclass Document(SoftDeleteModel):\n    title = models.CharField(max_length=100)\n    content = models.TextField()\n</code></pre>"},{"location":"models/soft_delete.html#features","title":"Features","text":"<ul> <li>Soft deletion with timestamp tracking</li> <li>Undelete capability</li> <li>Prevention of updates to deleted records</li> <li>Automatic filtering of deleted records</li> <li>Cascade and SET_NULL support for related objects</li> <li>Custom manager with additional query methods</li> <li>Pre/post signals for delete and undelete operations</li> </ul>"},{"location":"models/soft_delete.html#deletion-field","title":"Deletion Field","text":"<p>The model includes a <code>deleted_at</code> field that tracks deletion time:</p> <pre><code>deleted_at = models.DateTimeField(\n    blank=True,\n    null=True,\n    default=None\n)\n</code></pre>"},{"location":"models/soft_delete.html#usage-examples","title":"Usage Examples","text":""},{"location":"models/soft_delete.html#basic-operations","title":"Basic Operations","text":"<pre><code># Create and delete a document\ndoc = Document.objects.create(title=\"Important\", content=\"...\")\ndoc.delete()  # Soft delete (sets deleted_at)\n\n# Check deletion status\nprint(doc.is_deleted)  # True\nprint(doc.deleted_at)  # Current timestamp\n\n# Try to update deleted document\ndoc.title = \"New Title\"\ndoc.save()  # Raises UpdatingSoftDeletedException\n\n# Undelete the document\ndoc.undelete()\nprint(doc.is_deleted)  # False\nprint(doc.deleted_at)  # None\n\n# Hard delete (actual removal)\ndoc.delete()  # First soft delete\ndoc.delete()  # Second delete removes from database\n</code></pre>"},{"location":"models/soft_delete.html#querying","title":"Querying","text":"<pre><code># Default manager excludes deleted records\nactive_docs = Document.objects.all()\n\n# Include deleted records\nall_docs = Document.objects.all_with_deleted()\n\n# Bulk operations\nDocument.objects.filter(title__contains=\"draft\").delete()  # Soft delete\nDocument.objects.filter(title__contains=\"old\").hard_delete()  # Actually delete\n</code></pre>"},{"location":"models/soft_delete.html#related-objects","title":"Related Objects","text":""},{"location":"models/soft_delete.html#many-to-many-relationships","title":"Many-to-Many Relationships","text":"<p>The soft delete manager automatically handles soft-deleted objects in M2M relationships:</p> <pre><code>class Team(SoftDeleteModel):\n    name = models.CharField(max_length=100)\n    members = models.ManyToManyField('User', through='TeamMembership')\n\nclass TeamMembership(SoftDeleteModel):\n    team = models.ForeignKey(Team, on_delete=models.CASCADE)\n    user = models.ForeignKey('User', on_delete=models.CASCADE)\n\n# Queries will automatically exclude soft-deleted memberships\nactive_teams = Team.objects.filter(members__username=\"john\")\n</code></pre> <p>To control this behavior, configure the <code>SOFT_DELETE_M2M_EXCLUDE_DELETED</code> setting: <pre><code># settings.py\nSOFT_DELETE_M2M_EXCLUDE_DELETED = True  # Default: False\n</code></pre></p>"},{"location":"models/soft_delete.html#cascade-deletion","title":"Cascade Deletion","text":"<pre><code>class Newspaper(SoftDeleteModel):\n    name = models.CharField(max_length=100)\n\nclass Article(SoftDeleteModel):\n    newspaper = models.ForeignKey(\n        Newspaper,\n        on_delete=models.CASCADE\n    )\n    title = models.CharField(max_length=100)\n\n# When newspaper is deleted, articles are soft deleted too\nnewspaper = Newspaper.objects.create(name=\"Daily Prophet\")\nArticle.objects.create(newspaper=newspaper, title=\"Breaking News\")\nnewspaper.delete()  # Article is also soft deleted\n</code></pre>"},{"location":"models/soft_delete.html#set_null-handling","title":"SET_NULL Handling","text":"<pre><code>class News(SoftDeleteModel):\n    newspaper = models.ForeignKey(\n        Newspaper,\n        on_delete=models.SET_NULL,\n        null=True\n    )\n    title = models.CharField(max_length=100)\n\n# When newspaper is deleted, news references are set to null\nnewspaper = Newspaper.objects.create(name=\"Daily Prophet\")\nnews = News.objects.create(newspaper=newspaper, title=\"Event\")\nnewspaper.delete()  # news.newspaper becomes None\n</code></pre>"},{"location":"models/soft_delete.html#signal-handling","title":"Signal Handling","text":"<pre><code>from drf_kit.signals import pre_soft_delete, post_soft_delete\nfrom drf_kit.signals import pre_undelete, post_undelete\n\ndef handle_pre_delete(sender, instance, **kwargs):\n    print(f\"About to delete {instance}\")\n\ndef handle_post_delete(sender, instance, **kwargs):\n    print(f\"Deleted {instance}\")\n\npre_soft_delete.connect(handle_pre_delete, sender=Document)\npost_soft_delete.connect(handle_post_delete, sender=Document)\n</code></pre>"},{"location":"models/soft_delete.html#technical-details","title":"Technical Details","text":""},{"location":"models/soft_delete.html#custom-manager","title":"Custom Manager","text":"<pre><code>class SoftDeleteManager(models.Manager):\n    def get_queryset(self):\n        return super().get_queryset().filter(deleted_at__isnull=True)\n\n    def all_with_deleted(self):\n        return super().get_queryset()\n\n    def hard_delete(self):\n        return super().get_queryset().delete()\n</code></pre>"},{"location":"models/soft_delete.html#deletion-prevention","title":"Deletion Prevention","text":"<pre><code>def verify_soft_deletion(sender, instance, **kwargs):\n    if instance.is_deleted and not instance._state.adding:\n        raise exceptions.UpdatingSoftDeletedException()\n</code></pre>"},{"location":"models/soft_delete.html#best-practices","title":"Best Practices","text":"<ol> <li>Use SoftDeleteModel when you need to maintain deleted records</li> <li>Handle both soft-deleted and active records in your business logic</li> <li>Use signals for audit logging or related operations</li> <li>Consider storage implications of keeping deleted records</li> <li>Use hard delete for actual cleanup when needed</li> <li>Remember that unique constraints apply to both active and deleted records</li> <li>Consider implementing cleanup policies for old deleted records</li> </ol>"}]}